import glob from "fast-glob";
import { pathToFileURL } from "url";
import { getVercelOutput, removeDir, writeJson } from "../lib/fs.js";
import { copyDependenciesToFunction } from "../lib/nft.js";
import { getRedirects } from "../lib/redirects.js";
const PACKAGE_NAME = "@astrojs/vercel/serverless";
function getAdapter() {
  return {
    name: PACKAGE_NAME,
    serverEntrypoint: `${PACKAGE_NAME}/entrypoint`,
    exports: ["default"]
  };
}
function vercelServerless({
  includeFiles,
  excludeFiles
} = {}) {
  let _config;
  let buildTempFolder;
  let functionFolder;
  let serverEntry;
  let needsBuildConfig = false;
  return {
    name: PACKAGE_NAME,
    hooks: {
      "astro:config:setup": ({ config, updateConfig }) => {
        needsBuildConfig = !config.build.client;
        const outDir = getVercelOutput(config.root);
        updateConfig({
          outDir,
          build: {
            serverEntry: "entry.js",
            client: new URL("./static/", outDir),
            server: new URL("./dist/", config.root)
          }
        });
      },
      "astro:config:done": ({ setAdapter, config }) => {
        setAdapter(getAdapter());
        _config = config;
        buildTempFolder = config.build.server;
        functionFolder = new URL("./functions/render.func/", config.outDir);
        serverEntry = config.build.serverEntry;
        if (config.output === "static") {
          throw new Error(`
		[@astrojs/vercel] \`output: "server"\` is required to use the serverless adapter.
	
	`);
        }
      },
      "astro:build:start": ({ buildConfig }) => {
        if (needsBuildConfig) {
          buildConfig.client = new URL("./static/", _config.outDir);
          buildTempFolder = buildConfig.server = new URL("./dist/", _config.root);
          serverEntry = buildConfig.serverEntry = "entry.js";
        }
      },
      "astro:build:done": async ({ routes }) => {
        const inc = (includeFiles == null ? void 0 : includeFiles.map((file) => new URL(file, _config.root))) || [];
        if (_config.vite.assetsInclude) {
          const mergeGlobbedIncludes = (globPattern) => {
            if (typeof globPattern === "string") {
              const entries = glob.sync(globPattern).map((p) => pathToFileURL(p));
              inc.push(...entries);
            } else if (Array.isArray(globPattern)) {
              for (const pattern of globPattern) {
                mergeGlobbedIncludes(pattern);
              }
            }
          };
          mergeGlobbedIncludes(_config.vite.assetsInclude);
        }
        const { handler } = await copyDependenciesToFunction({
          entry: new URL(serverEntry, buildTempFolder),
          outDir: functionFolder,
          includeFiles: inc,
          excludeFiles: (excludeFiles == null ? void 0 : excludeFiles.map((file) => new URL(file, _config.root))) || []
        });
        await removeDir(buildTempFolder);
        await writeJson(new URL(`./package.json`, functionFolder), {
          type: "module"
        });
        await writeJson(new URL(`./.vc-config.json`, functionFolder), {
          runtime: getRuntime(),
          handler,
          launcherType: "Nodejs"
        });
        await writeJson(new URL(`./config.json`, _config.outDir), {
          version: 3,
          routes: [
            ...getRedirects(routes, _config),
            { handle: "filesystem" },
            { src: "/.*", dest: "render" }
          ]
        });
      }
    }
  };
}
function getRuntime() {
  const version = process.version.slice(1);
  const major = version.split(".")[0];
  return `nodejs${major}.x`;
}
export {
  vercelServerless as default
};
